特徴を表現する方法を
実例で見ていきましょう この例を使います 生データです アイスクリーム店の中で 特定の従業員が顧客に
アイスクリームを出すとき 未加工が1.4秒または
1.4分待ったかどうか そしてどんな評価（Rating）になるか つまり評価を予測します 顧客満足度を決めるのは どの従業員が対応したか、待ち時間、 何を買ったか、店の場所などです これが今回のデータです このトレーニングデータをすべて 適切な数値にする必要があります すべて数値にする
というルールでしたね ニューラルネットワークでは
数値を扱いますから データを数値にして これらが特徴です TensorFlowでは
このようなJSON入力が ウェブアプリから
データウェアハウスに送られます それを取り出して数値を作成し TensorFlowで各列を特徴列にします どうすればこのようなデータを
特徴列にできますか？ どのように数値にしますか？ まず価格や待ち時間などの値は すでに数値ですから 簡単にエンコーディングできて そのまま使えます これらは
意味のある等級（規模）を持つ数値です 2.5や1.4などの待ち時間は
TensorFlowで簡単に学習できます ですからこれを実数値列と呼びます 実数値列の価格の層や 実数値列の待ち時間の層などがあり これらの数値はそのまま使える
実数値列です ではこの入力はどうですか？ 取引ID（transaction Id）=42です これは限定的すぎるので 特徴としては使えません では従業員IDはどうですか employeeId=72365です これは数値ですか？
確かに数値ですが 意味のある等級を持っていません employeeId=72365は 36182の2倍も
優秀な従業員ですか？ 違いますね？ employeeIdはそのまま使えないので 加工が必要です アイスクリーム店の
従業員が5人だとします 従業員番号8345、
従業員番号72365などです ここでたとえば従業員番号が72365なら この従業員IDをご覧のように
ベクターで表現します ベクターは「01000」です
なぜなら 第2列を従業員72365に
対応させたからです ビットマスクにとても似ていますね この従業員の列を1にして
他をゼロにします これをワンホットエンコーディングと呼び 1つの列が「ホット」で 他はすべて「コールド」です アイスクリーム店に
5人の従業員がいる場合 列の数は5つですが
正確に言うと通常は4つにします なぜなら
1は線形独立だからです でも今は5人の従業員、
5つの列だとしましょう TensorFlowでは
疎（sparse）列といいます 皆様はキーを持つ疎列を
作ることを指定し 列名はemployeeId キーは8345、72365などの 従業員IDです 各キーの文字列を渡すと TensorFlowが文字列を受け入れて 直接的なトレーニング時や
予測時にそれを提供し ワンホットエンコーディングで表して すべて数値になります 皆様はここでemployeeIdを
疎列と指定します これはキーが事前にわかっている場合ですが キーが事前にわからない場合は？ 入力データを事前に加工し トレーニングデータセット内にある
すべてのキーを見つけて 「キーの語彙」を作成できます これが最初のステップつまり 事前処理です これをトレーニング前に行い 新しいデータセットを作成すると 事前処理した値を
使用できるようになります ですからモデルをトレーニングする前に キーの語彙を作成して この語彙を予測時に
使用可能にする必要があります そうしないと予測時に
困ったことになります 「従業員ID 72365を モデルのトレーニング時に
定義すべきだった 72365がワンホットエンコーディングの
第2列だと指定すべきだった」 語彙は同一でなければならず 語彙のマッピングが もしトレーニングと予測で同じでなければ 役に立ちません 多くの方はこう思うでしょう 「新しい従業員を雇っても まだ同じモデルを使えるの？」 今の時点では新しい従業員が入る
余地はありません つまり新しい従業員を予測できません こうしたことを事前に考えて 回避策を準備すべきです 不明な従業員や
見つからない従業員がいたら どうしますか？ たとえば現在の従業員の平均を出して その数値を仮に使うことができます 一方でその従業員の勤務時間や その従業員に関する顧客満足度を さまざまな待ち時間や
商品について収集し 収集できたらそれを予測で使えます ですからキーが事前にわかっている場合は そのキーを使って疎列を作成でき キーを渡して 加工していきます こうして多くの方法で疎列を作成できますが データがすでにインデックス化
されている場合もあります なぜインデックス化ですか？ たとえば従業員IDが 1～1000までの値だとしたら その時点でインデックス化されています 散在する大きな番号ではなく 範囲に収まっているので この場合は疎列を作成します 整数の特徴employeeIdを持ち 5人の従業員がいます これはたとえばタクシーの例で 時刻に使えて便利です 自動的に0～23の整数に
変換されるので 非数値である時刻から 整数に変換される特徴として最適です ただし完全な数値ではなく たとえば数値「23」は「0」に近く 「1」とは2時間しか離れていません 3つ目の可能性を考えましょう 語彙がなく
しかも 整数に変換されない場合でも 賢いやり方があります 語彙を構築したくない場合
もし嫌でなければ employeeIdをハッシュ化します employeeIdのハッシュを計算して それをたとえば500個の
バケットに分割します なぜ？ たとえば会社に100人の従業員がいる場合 500バケットの中にハッシュすると 平均して各従業員が1つのバケットを持ち 0人または1人がそれぞれに入るので まるで100個のエンコーディング または500個の
ワンホットエンコーディングです 語彙を最初に作らなくても
同じ結果になります ではcustomerRatingをどう扱いますか？ 顧客の評価の予測では これはラベルなので悩みませんが これを入力として使って 別の事柄を予測できます 評価のような指標を 入力特徴として使うと 次のいずれかを行えます まず1～5の連続的な数値として扱えます これは意味のある等級を持ち たとえば「2より3が大きい」 「4つ星は5つ星や2つ星と
まったく異なる」となり これはワンホットエンコーディングです 場合によっては 評価をワンホットエンコーディングするか 数値として扱うか選択でき これは評価をどのように
扱うかで決まります 1つ注意点があります お客様が評価をしなかった場合
どう処理しますか？ お客様がアンケートに答えなかった場合 欠損データをどう扱いますか？ たとえば2つの列を使うことができます 1つの列は評価
もう1つは評価の有無です この例の数値4は
お客様からの評価 1はお客様が評価をしたという事実 0はお客様が評価しなかったという事実です またはワンホットエンコーディングでも
処理でき たとえば4と評価されたら0001 評価されなかったら0000です ただし2番目の列（評価の有無）を
忘れないでください マジックナンバーと
実際の数値を混同すべきではありません 値が観測されたかどうかを表す
列を1つ追加してください 欠損データがある場合は その長さに関係なく もう1つの列が必要です