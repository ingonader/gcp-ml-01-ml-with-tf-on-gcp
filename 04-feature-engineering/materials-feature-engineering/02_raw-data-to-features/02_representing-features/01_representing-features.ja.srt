1
00:00:00,000 --> 00:00:03,610
特徴を表現する方法を
実例で見ていきましょう

2
00:00:03,610 --> 00:00:05,740
この例を使います

3
00:00:05,740 --> 00:00:07,365
生データです

4
00:00:07,365 --> 00:00:09,090
アイスクリーム店の中で

5
00:00:09,090 --> 00:00:12,220
特定の従業員が顧客に
アイスクリームを出すとき

6
00:00:12,220 --> 00:00:15,420
未加工が1.4秒または
1.4分待ったかどうか

7
00:00:15,420 --> 00:00:17,615
そしてどんな評価（Rating）になるか

8
00:00:17,615 --> 00:00:19,665
つまり評価を予測します

9
00:00:19,665 --> 00:00:22,295
顧客満足度を決めるのは

10
00:00:22,295 --> 00:00:25,070
どの従業員が対応したか、待ち時間、

11
00:00:25,070 --> 00:00:28,080
何を買ったか、店の場所などです

12
00:00:28,080 --> 00:00:30,585
これが今回のデータです

13
00:00:30,585 --> 00:00:32,934
このトレーニングデータをすべて

14
00:00:32,934 --> 00:00:35,525
適切な数値にする必要があります

15
00:00:35,525 --> 00:00:37,835
すべて数値にする
というルールでしたね

16
00:00:37,835 --> 00:00:40,810
ニューラルネットワークでは
数値を扱いますから

17
00:00:40,810 --> 00:00:42,740
データを数値にして

18
00:00:42,740 --> 00:00:44,520
これらが特徴です

19
00:00:44,520 --> 00:00:47,580
TensorFlowでは
このようなJSON入力が

20
00:00:47,580 --> 00:00:51,160
ウェブアプリから
データウェアハウスに送られます

21
00:00:51,160 --> 00:00:53,525
それを取り出して数値を作成し

22
00:00:53,525 --> 00:00:56,865
TensorFlowで各列を特徴列にします

23
00:00:56,865 --> 00:01:00,570
どうすればこのようなデータを
特徴列にできますか？

24
00:01:00,570 --> 00:01:02,740
どのように数値にしますか？

25
00:01:02,740 --> 00:01:06,310
まず価格や待ち時間などの値は

26
00:01:06,310 --> 00:01:08,060
すでに数値ですから

27
00:01:08,060 --> 00:01:10,350
簡単にエンコーディングできて

28
00:01:10,350 --> 00:01:12,220
そのまま使えます

29
00:01:12,220 --> 00:01:15,830
これらは
意味のある等級（規模）を持つ数値です

30
00:01:15,830 --> 00:01:21,205
2.5や1.4などの待ち時間は
TensorFlowで簡単に学習できます

31
00:01:22,345 --> 00:01:25,540
ですからこれを実数値列と呼びます

32
00:01:25,540 --> 00:01:29,235
実数値列の価格の層や

33
00:01:29,235 --> 00:01:32,210
実数値列の待ち時間の層などがあり

34
00:01:32,210 --> 00:01:37,425
これらの数値はそのまま使える
実数値列です

35
00:01:37,425 --> 00:01:39,600
ではこの入力はどうですか？

36
00:01:39,600 --> 00:01:42,585
取引ID（transaction Id）=42です

37
00:01:42,585 --> 00:01:44,670
これは限定的すぎるので

38
00:01:44,670 --> 00:01:47,230
特徴としては使えません

39
00:01:47,230 --> 00:01:49,940
では従業員IDはどうですか

40
00:01:49,940 --> 00:01:54,045
employeeId=72365です

41
00:01:54,045 --> 00:01:57,070
これは数値ですか？
確かに数値ですが

42
00:01:57,070 --> 00:01:59,655
意味のある等級を持っていません

43
00:01:59,655 --> 00:02:03,310
employeeId=72365は

44
00:02:03,310 --> 00:02:07,510
36182の2倍も
優秀な従業員ですか？

45
00:02:07,510 --> 00:02:09,235
違いますね？

46
00:02:09,235 --> 00:02:12,129
employeeIdはそのまま使えないので

47
00:02:12,129 --> 00:02:13,645
加工が必要です

48
00:02:13,645 --> 00:02:16,905
アイスクリーム店の
従業員が5人だとします

49
00:02:16,905 --> 00:02:22,980
従業員番号8345、
従業員番号72365などです

50
00:02:22,980 --> 00:02:27,075
ここでたとえば従業員番号が72365なら

51
00:02:27,075 --> 00:02:31,455
この従業員IDをご覧のように
ベクターで表現します

52
00:02:31,455 --> 00:02:35,380
ベクターは「01000」です
なぜなら

53
00:02:35,380 --> 00:02:40,375
第2列を従業員72365に
対応させたからです

54
00:02:40,375 --> 00:02:43,655
ビットマスクにとても似ていますね

55
00:02:43,655 --> 00:02:47,870
この従業員の列を1にして
他をゼロにします

56
00:02:47,870 --> 00:02:50,370
これをワンホットエンコーディングと呼び

57
00:02:50,370 --> 00:02:52,175
1つの列が「ホット」で

58
00:02:52,175 --> 00:02:54,010
他はすべて「コールド」です

59
00:02:54,010 --> 00:02:56,720
アイスクリーム店に
5人の従業員がいる場合

60
00:02:56,720 --> 00:03:00,995
列の数は5つですが
正確に言うと通常は4つにします

61
00:03:00,995 --> 00:03:03,875
なぜなら
1は線形独立だからです

62
00:03:03,875 --> 00:03:07,635
でも今は5人の従業員、
5つの列だとしましょう

63
00:03:07,635 --> 00:03:10,510
TensorFlowでは
疎（sparse）列といいます

64
00:03:10,510 --> 00:03:13,740
皆様はキーを持つ疎列を
作ることを指定し

65
00:03:13,740 --> 00:03:16,065
列名はemployeeId

66
00:03:16,065 --> 00:03:19,300
キーは8345、72365などの

67
00:03:19,300 --> 00:03:21,160
従業員IDです

68
00:03:21,160 --> 00:03:23,970
各キーの文字列を渡すと

69
00:03:23,970 --> 00:03:26,645
TensorFlowが文字列を受け入れて

70
00:03:26,645 --> 00:03:29,820
直接的なトレーニング時や
予測時にそれを提供し

71
00:03:29,820 --> 00:03:32,060
ワンホットエンコーディングで表して

72
00:03:32,060 --> 00:03:33,680
すべて数値になります

73
00:03:33,680 --> 00:03:37,430
皆様はここでemployeeIdを
疎列と指定します

74
00:03:37,430 --> 00:03:41,285
これはキーが事前にわかっている場合ですが

75
00:03:41,285 --> 00:03:44,050
キーが事前にわからない場合は？

76
00:03:45,290 --> 00:03:48,540
入力データを事前に加工し

77
00:03:48,540 --> 00:03:52,760
トレーニングデータセット内にある
すべてのキーを見つけて

78
00:03:52,760 --> 00:03:55,315
「キーの語彙」を作成できます

79
00:03:55,315 --> 00:03:57,210
これが最初のステップつまり

80
00:03:57,210 --> 00:03:58,640
事前処理です

81
00:03:58,640 --> 00:04:00,900
これをトレーニング前に行い

82
00:04:00,900 --> 00:04:03,160
新しいデータセットを作成すると

83
00:04:03,160 --> 00:04:06,150
事前処理した値を
使用できるようになります

84
00:04:06,150 --> 00:04:09,330
ですからモデルをトレーニングする前に

85
00:04:09,330 --> 00:04:11,410
キーの語彙を作成して

86
00:04:11,410 --> 00:04:14,955
この語彙を予測時に
使用可能にする必要があります

87
00:04:14,955 --> 00:04:18,024
そうしないと予測時に
困ったことになります

88
00:04:18,024 --> 00:04:19,980
「従業員ID 72365を

89
00:04:19,980 --> 00:04:22,885
モデルのトレーニング時に
定義すべきだった

90
00:04:22,885 --> 00:04:28,300
72365がワンホットエンコーディングの
第2列だと指定すべきだった」

91
00:04:28,300 --> 00:04:30,490
語彙は同一でなければならず

92
00:04:30,490 --> 00:04:32,350
語彙のマッピングが

93
00:04:32,350 --> 00:04:35,220
もしトレーニングと予測で同じでなければ

94
00:04:35,220 --> 00:04:36,910
役に立ちません

95
00:04:36,910 --> 00:04:38,980
多くの方はこう思うでしょう

96
00:04:38,980 --> 00:04:41,350
「新しい従業員を雇っても

97
00:04:41,350 --> 00:04:43,600
まだ同じモデルを使えるの？」

98
00:04:43,600 --> 00:04:47,130
今の時点では新しい従業員が入る
余地はありません

99
00:04:47,130 --> 00:04:50,030
つまり新しい従業員を予測できません

100
00:04:50,030 --> 00:04:52,304
こうしたことを事前に考えて

101
00:04:52,304 --> 00:04:54,234
回避策を準備すべきです

102
00:04:54,234 --> 00:04:57,355
不明な従業員や
見つからない従業員がいたら

103
00:04:57,355 --> 00:04:59,015
どうしますか？

104
00:04:59,015 --> 00:05:02,285
たとえば現在の従業員の平均を出して

105
00:05:02,285 --> 00:05:06,165
その数値を仮に使うことができます

106
00:05:06,165 --> 00:05:09,280
一方でその従業員の勤務時間や

107
00:05:09,280 --> 00:05:12,220
その従業員に関する顧客満足度を

108
00:05:12,220 --> 00:05:15,280
さまざまな待ち時間や
商品について収集し

109
00:05:15,280 --> 00:05:19,125
収集できたらそれを予測で使えます

110
00:05:19,125 --> 00:05:22,660
ですからキーが事前にわかっている場合は

111
00:05:22,660 --> 00:05:25,270
そのキーを使って疎列を作成でき

112
00:05:25,270 --> 00:05:26,830
キーを渡して

113
00:05:26,830 --> 00:05:28,440
加工していきます

114
00:05:28,440 --> 00:05:31,470
こうして多くの方法で疎列を作成できますが

115
00:05:31,470 --> 00:05:35,090
データがすでにインデックス化
されている場合もあります

116
00:05:35,090 --> 00:05:37,250
なぜインデックス化ですか？

117
00:05:37,250 --> 00:05:39,130
たとえば従業員IDが

118
00:05:39,130 --> 00:05:41,780
1～1000までの値だとしたら

119
00:05:41,780 --> 00:05:44,365
その時点でインデックス化されています

120
00:05:44,365 --> 00:05:46,310
散在する大きな番号ではなく

121
00:05:46,310 --> 00:05:48,080
範囲に収まっているので

122
00:05:48,080 --> 00:05:50,330
この場合は疎列を作成します

123
00:05:50,330 --> 00:05:52,730
整数の特徴employeeIdを持ち

124
00:05:52,730 --> 00:05:54,645
5人の従業員がいます

125
00:05:54,645 --> 00:05:57,910
これはたとえばタクシーの例で

126
00:05:57,910 --> 00:06:00,570
時刻に使えて便利です

127
00:06:00,570 --> 00:06:04,035
自動的に0～23の整数に
変換されるので

128
00:06:04,035 --> 00:06:06,180
非数値である時刻から

129
00:06:06,180 --> 00:06:08,690
整数に変換される特徴として最適です

130
00:06:08,690 --> 00:06:10,760
ただし完全な数値ではなく

131
00:06:10,760 --> 00:06:13,025
たとえば数値「23」は「0」に近く

132
00:06:13,025 --> 00:06:15,615
「1」とは2時間しか離れていません

133
00:06:15,615 --> 00:06:17,835
3つ目の可能性を考えましょう

134
00:06:17,835 --> 00:06:20,310
語彙がなく
しかも

135
00:06:20,310 --> 00:06:22,730
整数に変換されない場合でも

136
00:06:22,730 --> 00:06:24,765
賢いやり方があります

137
00:06:24,765 --> 00:06:29,600
語彙を構築したくない場合
もし嫌でなければ

138
00:06:29,600 --> 00:06:32,990
employeeIdをハッシュ化します

139
00:06:32,990 --> 00:06:35,500
employeeIdのハッシュを計算して

140
00:06:35,500 --> 00:06:38,820
それをたとえば500個の
バケットに分割します

141
00:06:38,820 --> 00:06:40,370
なぜ？

142
00:06:40,370 --> 00:06:42,950
たとえば会社に100人の従業員がいる場合

143
00:06:42,950 --> 00:06:45,240
500バケットの中にハッシュすると

144
00:06:45,240 --> 00:06:47,930
平均して各従業員が1つのバケットを持ち

145
00:06:47,930 --> 00:06:50,330
0人または1人がそれぞれに入るので

146
00:06:50,330 --> 00:06:52,360
まるで100個のエンコーディング

147
00:06:52,360 --> 00:06:55,230
または500個の
ワンホットエンコーディングです

148
00:06:55,230 --> 00:06:59,355
語彙を最初に作らなくても
同じ結果になります

149
00:06:59,355 --> 00:07:03,675
ではcustomerRatingをどう扱いますか？

150
00:07:03,675 --> 00:07:05,580
顧客の評価の予測では

151
00:07:05,580 --> 00:07:08,050
これはラベルなので悩みませんが

152
00:07:08,050 --> 00:07:10,300
これを入力として使って

153
00:07:10,300 --> 00:07:12,540
別の事柄を予測できます

154
00:07:12,540 --> 00:07:14,539
評価のような指標を

155
00:07:14,539 --> 00:07:16,660
入力特徴として使うと

156
00:07:16,660 --> 00:07:18,485
次のいずれかを行えます

157
00:07:18,485 --> 00:07:22,030
まず1～5の連続的な数値として扱えます

158
00:07:22,030 --> 00:07:24,740
これは意味のある等級を持ち

159
00:07:24,740 --> 00:07:27,600
たとえば「2より3が大きい」

160
00:07:27,600 --> 00:07:32,135
「4つ星は5つ星や2つ星と
まったく異なる」となり

161
00:07:32,135 --> 00:07:35,045
これはワンホットエンコーディングです

162
00:07:35,045 --> 00:07:36,345
場合によっては

163
00:07:36,345 --> 00:07:39,015
評価をワンホットエンコーディングするか

164
00:07:39,015 --> 00:07:41,075
数値として扱うか選択でき

165
00:07:41,075 --> 00:07:44,570
これは評価をどのように
扱うかで決まります

166
00:07:44,570 --> 00:07:47,560
1つ注意点があります

167
00:07:47,560 --> 00:07:51,720
お客様が評価をしなかった場合
どう処理しますか？

168
00:07:51,720 --> 00:07:54,825
お客様がアンケートに答えなかった場合

169
00:07:54,825 --> 00:07:57,160
欠損データをどう扱いますか？

170
00:07:57,160 --> 00:08:00,090
たとえば2つの列を使うことができます

171
00:08:00,090 --> 00:08:03,345
1つの列は評価
もう1つは評価の有無です

172
00:08:03,345 --> 00:08:07,290
この例の数値4は
お客様からの評価

173
00:08:07,290 --> 00:08:10,230
1はお客様が評価をしたという事実

174
00:08:10,230 --> 00:08:13,635
0はお客様が評価しなかったという事実です

175
00:08:13,635 --> 00:08:17,230
またはワンホットエンコーディングでも
処理でき

176
00:08:17,230 --> 00:08:20,615
たとえば4と評価されたら0001

177
00:08:20,615 --> 00:08:24,015
評価されなかったら0000です

178
00:08:24,015 --> 00:08:28,280
ただし2番目の列（評価の有無）を
忘れないでください

179
00:08:28,280 --> 00:08:32,015
マジックナンバーと
実際の数値を混同すべきではありません

180
00:08:32,015 --> 00:08:36,754
値が観測されたかどうかを表す
列を1つ追加してください

181
00:08:36,754 --> 00:08:38,660
欠損データがある場合は

182
00:08:38,660 --> 00:08:40,160
その長さに関係なく

183
00:08:40,160 --> 00:08:41,940
もう1つの列が必要です