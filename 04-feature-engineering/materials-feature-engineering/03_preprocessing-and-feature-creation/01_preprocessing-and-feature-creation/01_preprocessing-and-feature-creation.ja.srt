1
00:00:00,000 --> 00:00:01,760
Googleのプログラムマネージャーの

2
00:00:01,760 --> 00:00:04,130
Carl Osipovです

3
00:00:04,130 --> 00:00:06,270
Google Cloudをご利用のお客様が

4
00:00:06,270 --> 00:00:12,370
スケーラブルで本番環境に対応した
MLシステムを導入するサポートしています

5
00:00:12,390 --> 00:00:14,715
ここではMLシステムの

6
00:00:14,715 --> 00:00:18,490
特徴量セットを準備するための2つの手法

7
00:00:18,490 --> 00:00:22,900
入力データの前処理と
特徴量の作成を取り上げます

8
00:00:22,900 --> 00:00:27,110
まず 前処置と特徴量作成の例を見ながら

9
00:00:27,110 --> 00:00:30,020
特徴エンジニアリングの
一部であるこれらを適用する際の

10
00:00:30,020 --> 00:00:32,800
課題について説明します

11
00:00:32,800 --> 00:00:36,050
次に こうした課題の解決に役立つ

12
00:00:36,050 --> 00:00:40,540
Google Cloud Dataflowや
Cloud Dataprepなどの

13
00:00:40,540 --> 00:00:42,585
ツールについて説明します

14
00:00:42,585 --> 00:00:51,230
それでは 前処理と特徴量作成を行うのは
どのような場合なのか例を挙げて見ていきます

15
00:00:51,230 --> 00:00:55,220
特徴量の一部の値は MLモデルに渡す前に

16
00:00:55,220 --> 00:00:58,865
正規化しスケール変換する必要があります

17
00:00:58,865 --> 00:01:03,010
スケール変換とは 価格などの実数値の特徴量を

18
00:01:03,010 --> 00:01:07,275
表示された式で0～1の範囲に変換することです

19
00:01:07,275 --> 00:01:11,325
スケール変換を行う理由はさまざまですが

20
00:01:11,325 --> 00:01:17,105
通常は 勾配降下法の
パフォーマンス向上を目的としています

21
00:01:17,105 --> 00:01:20,905
この式でスケール変換するには

22
00:01:20,905 --> 00:01:24,570
特徴量の最小値と最大値が必要です

23
00:01:24,570 --> 00:01:26,645
それらの値がわからなければ

24
00:01:26,645 --> 00:01:31,315
データセット全体を前処理して
値を求める必要があります

25
00:01:31,315 --> 00:01:35,050
前処理は 画面のコードのように

26
00:01:35,050 --> 00:01:39,135
都市名などのデータセットの
カテゴリ値にも有効です

27
00:01:39,135 --> 00:01:41,775
たとえば TensorFlowで

28
00:01:41,775 --> 00:01:45,195
ワンホットエンコーディングにより

29
00:01:45,195 --> 00:01:48,915
各都市を2進値の特徴量で表すなら

30
00:01:48,915 --> 00:01:54,545
Layers APIのcategorical_column_
with_vocabulary_listメソッドを使用できます

31
00:01:54,545 --> 00:02:01,160
このメソッドを使用するには
都市名などの値のリストを渡す必要があります

32
00:02:01,160 --> 00:02:04,055
keyに入れるこの値の辞書がなければ

33
00:02:04,055 --> 00:02:08,765
データセット全体の前処理を行って作成します

34
00:02:08,785 --> 00:02:11,235
このモジュールでは3つの

35
00:02:11,235 --> 00:02:14,375
前処理テクノロジーを紹介します

36
00:02:14,375 --> 00:02:17,210
BigQueryとApache Beamは

37
00:02:17,210 --> 00:02:20,960
トレーニング前に
入力データセット全体を処理します

38
00:02:20,970 --> 00:02:30,725
一部のデータポイントの除外や基本統計量と
ボキャブラリの計算などを行います

39
00:02:30,725 --> 00:02:33,775
特徴量によっては 一定期間内の

40
00:02:33,775 --> 00:02:35,780
統計量が必要です

41
00:02:35,780 --> 00:02:38,210
たとえば あるサイトで

42
00:02:38,210 --> 00:02:41,690
1時間に売り上げた製品数などには

43
00:02:41,690 --> 00:02:47,075
Beamのバッチおよびストリーム
データパイプラインを使用します

44
00:02:47,075 --> 00:02:49,225
その他の特徴量は

45
00:02:49,225 --> 00:02:54,855
TensorFlowに直接または
Beamを使って実装できます

46
00:02:54,855 --> 00:02:57,340
このため Apache Beamと

47
00:02:57,340 --> 00:03:03,600
相補的なGoogle Cloudテクノロジー
Cloud Dataflowが重要です

48
00:03:03,600 --> 00:03:06,975
まず BigQueryとTensorFlowのみの

49
00:03:06,975 --> 00:03:09,850
特徴エンジニアリングの制限について

50
00:03:09,850 --> 00:03:13,730
次に Beamを使った対処法について
説明します

51
00:03:13,730 --> 00:03:17,705
BigQueryは Google Cloudサービスの一つで
高速でスケーラブルな

52
00:03:17,705 --> 00:03:21,000
フルマネージドのデータウェアハウスです

53
00:03:21,000 --> 00:03:24,650
標準SQLで前処理を実装できるため

54
00:03:24,650 --> 00:03:27,160
特徴量エンジニアリングに有効です

55
00:03:27,160 --> 00:03:30,490
たとえば NYのタクシー利用に関する

56
00:03:30,490 --> 00:03:34,060
100億件のデータセットを前処理する場合

57
00:03:34,060 --> 00:03:38,210
中には不正なデータが
含まれている場合があります

58
00:03:38,210 --> 00:03:43,975
この場合 不正なデータを排除する
SQLステートメントを書いて

59
00:03:43,975 --> 00:03:47,560
BigQueryで数秒で実行できます

60
00:03:47,560 --> 00:03:51,490
標準SQLの数学関数やデータ処理関数を使った

61
00:03:51,490 --> 00:03:54,575
その他のステートメントも使用できます

62
00:03:54,575 --> 00:03:58,720
ソースデータの加算などの簡単な計算や

63
00:03:58,720 --> 00:04:03,270
タイムスタンプから時刻を抽出するなどの

64
00:04:03,270 --> 00:04:06,655
データ形式の解析に役立ちます

65
00:04:06,655 --> 00:04:10,130
SQLを使って前処理を行う場合

66
00:04:10,130 --> 00:04:13,000
必ず TensorFlowでも

67
00:04:13,000 --> 00:04:16,905
まったく同じ前処理ロジックを実装します

68
00:04:16,905 --> 00:04:21,215
次に TensorFlowで
前処理コードを書く方法を

69
00:04:21,215 --> 00:04:23,125
2つ紹介します

70
00:04:23,125 --> 00:04:26,660
実際には1つ目か2つ目の方法のどちらか

71
00:04:26,660 --> 00:04:29,435
または両方を使うこともあります

72
00:04:29,435 --> 00:04:32,300
一般的な前処理であれば

73
00:04:32,300 --> 00:04:38,060
TensorFlowの特徴量カラムAPIの
既存メソッド使って書くことができます

74
00:04:38,060 --> 00:04:42,630
たとえば 実数値の特徴量を
離散値に変換するなら

75
00:04:42,630 --> 00:04:46,100
bucketized_columnメソッドを使用できます

76
00:04:46,100 --> 00:04:49,370
TensorFlowAPIで既存のものがない場合でも

77
00:04:49,370 --> 00:04:52,150
学習、検証、テスト時に

78
00:04:52,150 --> 00:04:57,370
入力パラメータに使用する関数を変更できます

79
00:04:57,370 --> 00:05:00,600
詳しく説明していきます

80
00:05:01,190 --> 00:05:05,760
まず 独自の前処理コードを実装する場合です

81
00:05:05,760 --> 00:05:08,735
ここでは 前処理コードが

82
00:05:08,735 --> 00:05:12,850
add_engineeredメソッドで
パッケージ化されていて

83
00:05:12,850 --> 00:05:16,945
ソースデータセットの
グローバル統計量は必要ありません

84
00:05:16,945 --> 00:05:22,135
緯度、経度による座標データから
ユークリッド距離を計算するため

85
00:05:22,135 --> 00:05:25,860
コードは元の特徴量辞書と

86
00:05:25,860 --> 00:05:29,940
距離の式で求めた新しい特徴量を返します

87
00:05:29,940 --> 00:05:32,460
学習、評価、供給段階に

88
00:05:32,460 --> 00:05:35,675
ユークリッド距離が含まれるよう

89
00:05:35,675 --> 00:05:39,525
対応するinput-fn関数はすべて

90
00:05:39,525 --> 00:05:44,440
add_engineeredメソッドの呼び出しで
前処理された特徴量をラップしています

91
00:05:44,440 --> 00:05:48,780
次に 既存の前処理ステップを使用する場合です

92
00:05:48,780 --> 00:05:52,070
適当なヘルパーメソッドを呼び出して

93
00:05:52,070 --> 00:05:54,710
特徴量カラムを定義できます

94
00:05:54,710 --> 00:05:58,380
ここではbucketized_columnメソッド使って

95
00:05:58,380 --> 00:06:01,430
ソースデータから緯度を求め

96
00:06:01,430 --> 00:06:05,485
値を38～42の範囲内に収めています

97
00:06:05,485 --> 00:06:08,130
次に 元の緯度の値は

98
00:06:08,130 --> 00:06:11,240
相互排他的なバケットに配置され

99
00:06:11,240 --> 00:06:16,885
範囲内のバケット数は最後のバケットの
パラメータで制御されます

100
00:06:16,885 --> 00:06:20,360
BigQueryのSQLとTensorFlowでの

101
00:06:20,360 --> 00:06:24,450
前処理コードの管理は
複雑で困難な場合があります

102
00:06:24,450 --> 00:06:28,780
Apache Beamを利用した
前処理の利点の一つは

103
00:06:28,780 --> 00:06:32,010
モデルの学習と供給の両方で

104
00:06:32,010 --> 00:06:35,460
同じコードを使用できることです

105
00:06:35,460 --> 00:06:38,225
ただし TensorFlowの

106
00:06:38,225 --> 00:06:42,445
便利なヘルパーメソッドは使用できません

107
00:06:42,445 --> 00:06:44,890
つまり この例のように

108
00:06:44,890 --> 00:06:48,020
独自のコードの実装が必要です

109
00:06:48,020 --> 00:06:50,360
このモジュールでは

110
00:06:50,360 --> 00:06:55,520
Apache Beamを使った
前処理の例を紹介しました