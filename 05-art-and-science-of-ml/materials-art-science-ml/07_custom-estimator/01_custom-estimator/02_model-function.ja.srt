1
00:00:00,000 --> 00:00:03,600
皆様が ある論文を
読むとします

2
00:00:03,600 --> 00:00:08,825
その中で 時系列の将来値を予測する
優れたモデルが扱われています

3
00:00:08,825 --> 00:00:10,825
コードも掲載されています

4
00:00:10,825 --> 00:00:13,985
LSTMCellなどの聞き慣れない概念や

5
00:00:13,985 --> 00:00:18,295
Static_rnnなどの見慣れない
TensorFlow関数を使っています

6
00:00:18,295 --> 00:00:23,205
Matmulなどの
低レベルTensorFlow操作も少し行います

7
00:00:23,205 --> 00:00:27,245
今のところ これらの用語の意味や
機能は心配しないでください

8
00:00:27,245 --> 00:00:31,770
この点は 専門分野のコース9
シーケンスモデルで見ていきます

9
00:00:31,770 --> 00:00:36,590
ここでは この関数を単なる
ブラックボックスとして扱いましょう

10
00:00:36,590 --> 00:00:39,935
基本的に 入力は時系列です

11
00:00:39,935 --> 00:00:43,515
時間を表す値からなる配列です

12
00:00:43,515 --> 00:00:47,450
N_INPUTSはこの時系列の長さです

13
00:00:47,450 --> 00:00:50,780
predictions（予測）はモデルの出力です

14
00:00:50,780 --> 00:00:54,480
出力配列には N_OUTPUTS数があります

15
00:00:54,480 --> 00:01:00,430
これらは このモデルで予測される
時系列の将来値を表します

16
00:01:00,430 --> 00:01:04,015
さて 皆様はこのモデルを
トレーニングしたいと考えます

17
00:01:04,015 --> 00:01:09,960
でも これはモデルに過ぎません
単なる数学です

18
00:01:09,960 --> 00:01:12,680
依然としてデータを読み込む必要があり

19
00:01:12,680 --> 00:01:15,550
トレーニングして評価する必要もあります

20
00:01:15,550 --> 00:01:19,225
これを分散型の
フォールトトレラントな方法で行い

21
00:01:19,225 --> 00:01:22,605
仕組みを少し調整したいと
思うかもしれません

22
00:01:22,605 --> 00:01:25,925
これをEstimatorフレームワークに
まとめるのが適切でしょう

23
00:01:25,925 --> 00:01:28,575
この方法で
分散トレーニングや

24
00:01:28,575 --> 00:01:31,095
スケーリングされた予測などが
得られるからです

25
00:01:31,095 --> 00:01:33,915
では それを行う方法を
見ていきましょう

26
00:01:33,915 --> 00:01:38,735
最初にtrain_and_evaluate
関数を見てください

27
00:01:38,735 --> 00:01:45,740
estimator、train_spec、eval_specという
3つのパラメータがあります

28
00:01:45,740 --> 00:01:50,970
train_specとeval_specは
定型Estimatorのパラメータと同じで

29
00:01:50,970 --> 00:01:56,445
これらは入力関数とデータセットを使って
データの入力方法を管理します

30
00:01:56,445 --> 00:01:58,990
さらに トレーニングの時間の長さ、

31
00:01:58,990 --> 00:02:02,750
評価の頻度、
エクスポートのタイミングも管理します

32
00:02:02,750 --> 00:02:09,290
ここで違うのはtrain_and_evaluateの
最初のパラメータestimatorです

33
00:02:09,290 --> 00:02:15,290
以前には 線形回帰、DNN回帰、
線形分類器などを作成することで

34
00:02:15,290 --> 00:02:18,030
Estimatorを作りました

35
00:02:18,030 --> 00:02:21,845
こうして定型つまり作成済み
Estimatorを作りました

36
00:02:21,845 --> 00:02:26,290
しかし今は 基底クラスEstimatorを作ります

37
00:02:26,290 --> 00:02:32,990
ここでは estimatorを単に
tf.estimators.Estimatorに設定しています

38
00:02:32,990 --> 00:02:36,955
基底クラスestimatorには
2つのパラメータがあります

39
00:02:36,955 --> 00:02:40,460
2番目のパラメータは定型Estimatorです

40
00:02:40,460 --> 00:02:44,385
これはチェックポイントを保存する
出力ディレクトリです

41
00:02:44,385 --> 00:02:48,410
1番目のパラメータはモデル関数です

42
00:02:48,410 --> 00:02:53,780
このモデル関数myfuncはどんな関数ですか

43
00:02:53,780 --> 00:02:59,050
myfuncはestimator_specです

44
00:02:59,050 --> 00:03:06,755
つまり myfuncは
tf.estimater.EstimatorSpecを返します

45
00:03:06,755 --> 00:03:11,380
3つのパラメータ features、targets、
modeを受け入れます

46
00:03:11,380 --> 00:03:14,600
featuresとtargetsは
聞き覚えがあるでしょう

47
00:03:14,600 --> 00:03:18,860
たとえばトレーニング入力関数から
これが返されます

48
00:03:18,860 --> 00:03:21,750
featuresは複数の特徴からなる辞書です

49
00:03:21,750 --> 00:03:23,170
この場合

50
00:03:23,170 --> 00:03:28,490
その辞書から
INCOLに対応するテンソルを導き出します

51
00:03:28,490 --> 00:03:31,330
targetsは単なるラベルです

52
00:03:31,330 --> 00:03:35,820
これも トレーニング入力関数から返されます

53
00:03:35,820 --> 00:03:41,265
modeは3つの値
train、eval、predictのいずれかです

54
00:03:41,265 --> 00:03:45,295
このモデルが必要になる理由を
間もなくお見せします

55
00:03:45,295 --> 00:03:48,010
この3つの入力値のうち

56
00:03:48,010 --> 00:03:54,770
myfuncの役割は
estimator_specを作成して返すことです

57
00:03:54,770 --> 00:03:58,040
eestimator_specには
6つのものが含まれます

58
00:03:58,040 --> 00:04:01,065
最初のパラメータmodeでは単に

59
00:04:01,065 --> 00:04:04,900
入力されたものを
そのまま渡すだけです

60
00:04:04,900 --> 00:04:10,600
2番目のパラメータpredictionsは
モデルの出力です

61
00:04:10,600 --> 00:04:13,950
predictionsは辞書である必要があります

62
00:04:13,950 --> 00:04:17,779
キー名と対応するテンソルを提供します

63
00:04:17,779 --> 00:04:21,975
ここでは predictions_dictが
1つのキーだけで構成されます

64
00:04:22,655 --> 00:04:25,280
それをpredictedと呼びます

65
00:04:25,280 --> 00:04:30,540
テンソルはもちろん
論文のモデルの出力です

66
00:04:31,350 --> 00:04:36,135
predictionsを使用して
エクスポート済み出力を作成します

67
00:04:36,135 --> 00:04:41,035
predictionsだけでなくそれ以外のものも
エクスポートできます

68
00:04:41,035 --> 00:04:43,110
たとえばモデルから

69
00:04:43,110 --> 00:04:45,940
学習済みの埋め込みをエクスポートできます

70
00:04:45,940 --> 00:04:50,990
ここで キーと
それに対応するテンソルを指定します

71
00:04:50,990 --> 00:04:54,535
estimator_specの
他の構成要素も見てみましょう

72
00:04:54,535 --> 00:04:57,950
つまり損失loss、
トレーニングオペレーションtrain_op、

73
00:04:57,950 --> 00:05:00,340
評価指標オペレーション
eval_metric_opsです

74
00:05:00,340 --> 00:05:06,320
trainモードの場合にのみ
train_opを実施する必要があります

75
00:05:06,320 --> 00:05:11,975
evalモードの場合にのみ
評価指標を計算する必要があります

76
00:05:11,975 --> 00:05:19,100
lossをtargets、labels、predictionsの間の
平均2乗誤差に設定します

77
00:05:19,100 --> 00:05:21,160
train_opはこの場合

78
00:05:21,160 --> 00:05:27,570
確率最急降下（SGD）を使用した
損失関数の最適化からなります

79
00:05:27,570 --> 00:05:31,075
このモデルではSGDが使用されると

80
00:05:31,075 --> 00:05:34,005
論文に書かれているという想定です

81
00:05:34,005 --> 00:05:36,290
評価指標は辞書です

82
00:05:36,290 --> 00:05:39,970
評価するすべての指標で構成されます

83
00:05:39,980 --> 00:05:43,710
ここでは 2乗平均平方根誤差だけを計算します

84
00:05:43,710 --> 00:05:48,970
予測の際にはこれらの
どのオペレーションも実行されません

85
00:05:48,970 --> 00:05:52,730
その理由はラベルがないからです

86
00:05:52,730 --> 00:05:57,980
ですから すべてのオペレーション（op）を
単にnoneに設定しました

87
00:05:57,980 --> 00:06:03,450
要約すると基底クラスestimatorで
train_and_evaluateを呼び出します

88
00:06:03,450 --> 00:06:07,345
その際 estimator_specを返す関数を渡します

89
00:06:07,345 --> 00:06:10,610
これで カスタムEstimatorができました