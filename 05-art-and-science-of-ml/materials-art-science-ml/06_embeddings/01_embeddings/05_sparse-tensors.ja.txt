入力ベクトルを
ワンホットエンコードされた配列として 保存するのはおすすめしません 密表現は保管にも演算にも
極めて非効率的です ここでは入力テンソルの
すべての値を保管する場所を みな密テンソルと呼んでいます これはテンソルに保管される
実際のデータとは無関係で 単に保管方法を表しています たとえばこのマトリックスですが データは密でしょうか疎でしょうか もちろん非常に疎ですね このマトリックスの例はみな
ユーザーが見た映画を表しています 自分の経験で考えても 評価を付けた映画は多くありませんよね ですから情報を密のフォームには
入力しません テンソルのすべての値を
保管する必要はないからです では密フォームを使用せず テンソルのすべての値を
保管しないとして 代わりにどうするかというと データは圧縮したうえで メモリに疎に保管することにします こうすれば疎テンソルを
密表現に変換することなく 行列乗算のような演算を 疎テンソルで直接
行うことができます このために各フィーチャーから整数への
ディクショナリマッピングを作成します たとえば『シュレック』は整数0とし 『ハリー・ポッター』は300や230など
任意の数値にします この時点では埋め込みはありません この時点では単にそれぞれの映画に
任意の整数が関連付けられています そして特定のユーザーが見た
映画を表すマトリックス行ができたら 単にそのユーザーが見た映画の
映画IDを保存します この例の行には
3つの映画が示されていますので 疎テンソルには
3つのエントリがあります このリストに含まれない整数については その映画は見られていないものと
考えられます ですから対応する密表現では この3つのエントリは1で
残りは0となっています ですので手順は2つです ディクショナリを計算する
前処理手順と ディクショナリを使用して効率的な
疎表現を作成する2番目の手順です これがカテゴリ列のボキャブラリ構築に
似ているなと思われた方は まさに正解です カテゴリ列はTensorFlowで
疎テンソルとして表されます カテゴリ列は
疎なものの例です TensorFlowは疎テンソルを
密に変換することなく 疎テンソルの演算操作を
実行できます このためメモリが節約され
演算も最適化されます カテゴリ列からフィーチャークロスを
作成する方法も説明しましたが あれは完全に疎テンソルに関して
行われる演算の例です そのため緯度と経度などという
離散化した列を掛け合わせても タクシーの乗車ポイントと降車ポイントの
フィーチャークロスを行っても メモリにも演算速度にも
問題は出ないのです またフィーチャークロスから埋め込み列を
作成する方法も紹介しましたが もちろん同じコードを
単一のカテゴリ列にも使用できます それがこれです TensorFlowでカテゴリデータから
埋め込み列を作成するコードが メモリや速度の問題を引き起こさずに
機能できるのは 疎テンソルを扱うことができるからです これがマジカルな実装の
鍵の1つです お話したとおり埋め込みに
別個のトレーニングプロセスは不要です 手順は2つだけです まず元の入力情報を表現し 次にそれを埋め込み層に送ります 最初の手順では入力された情報を
疎テンソルとして表します 2番目の手順では埋め込み列を
呼び出すわけですが このコードは実際
どのように機能するのでしょうか