1
00:00:00,000 --> 00:00:01,900
前のレッスンでは

2
00:00:01,900 --> 00:00:06,090
ルールを使用して埋め込みを
手動で作成する方法を説明しました

3
00:00:06,090 --> 00:00:12,530
観客の平均年齢や
チケットの売上総数といった属性を利用して

4
00:00:12,530 --> 00:00:17,310
50万の次元空間ができるはずの映画を

5
00:00:17,310 --> 00:00:20,760
すべて2次元空間に投影しました

6
00:00:20,760 --> 00:00:23,465
この2次元埋め込みでは

7
00:00:23,465 --> 00:00:28,475
軸に「年齢」や「チケット売り上げ」のほか

8
00:00:28,475 --> 00:00:33,225
「アート系/ヒット作」
「子供/成人」などの名前をつけました

9
00:00:33,225 --> 00:00:37,740
ただ必ずしも軸に名前を
付ける必要はありません

10
00:00:37,740 --> 00:00:42,765
重要なのは次元数が50万から
2つに減ったということです

11
00:00:42,765 --> 00:00:47,560
これは映画の属性を手動で
確認することで実現しました

12
00:00:47,560 --> 00:00:54,275
50万から2つへの次元縮退を行うことで
どのような影響があるでしょうか

13
00:00:54,275 --> 00:01:01,100
それぞれの映画の2D埋め込みは
2つの実数値に関連付けられていますので

14
00:01:01,100 --> 00:01:05,875
2D空間を指せば
それぞれの映画を表すことができます

15
00:01:05,875 --> 00:01:11,675
この埋め込みを行う
重要な理由の1つを説明します

16
00:01:11,675 --> 00:01:14,335
たとえばあるユーザーが
ある映画を気に入るかどうか

17
00:01:14,335 --> 00:01:17,855
予測するようにモデルを
トレーニングするとします

18
00:01:17,855 --> 00:01:20,574
Dの情報を持つモデルは

19
00:01:20,574 --> 00:01:24,880
Nの情報を持つモデルよりも
トレーニングが容易です

20
00:01:24,880 --> 00:01:29,260
NはDよりはるかに大きいからです

21
00:01:29,260 --> 00:01:35,645
情報ノードの数が少ないほど
最適化を要する重みが少なくなります

22
00:01:35,645 --> 00:01:39,240
すなわちモデルのトレーニングが高速化し

23
00:01:39,240 --> 00:01:42,235
過学習の可能性も低下します

24
00:01:42,235 --> 00:01:46,505
埋め込みは問題を単純化する手法です

25
00:01:46,505 --> 00:01:48,950
ただしこの次元縮退は

26
00:01:48,950 --> 00:01:53,290
情報が失われないように
行う必要があります

27
00:01:53,290 --> 00:01:58,960
適切な埋め込みを行うには
どうすればいいでしょうか

28
00:01:58,960 --> 00:02:04,605
埋め込みは通常のトレーニングプロセスの
一部としてデータから学習できます

29
00:02:04,605 --> 00:02:07,470
別個のプロセスは不要です

30
00:02:07,470 --> 00:02:14,300
まず元の情報をワンホットエンコードされた
配列として表し

31
00:02:14,310 --> 00:02:17,400
それを埋め込み層に送ります

32
00:02:17,400 --> 00:02:20,585
このアプローチでは埋め込み層は

33
00:02:20,585 --> 00:02:25,675
1次元あたりユニット数1の
単なる隠れ層です

34
00:02:25,695 --> 00:02:29,320
モデルのトレーニングでは
ラベルを使用しますので

35
00:02:29,320 --> 00:02:33,217
埋め込みはこのラベルに
基づいて変化します

36
00:02:33,217 --> 00:02:37,540
隠れユニットは直感的に
D次元空間の項目を

37
00:02:37,540 --> 00:02:42,130
整理する方法を見つけ出し

38
00:02:42,130 --> 00:02:45,770
最終目標を有効に最適化します

39
00:02:45,770 --> 00:02:48,065
ちょっとした問題として

40
00:02:48,065 --> 00:02:52,550
情報の保管にどれだけのメモリが
必要かということがあります

41
00:02:52,550 --> 00:02:55,310
カテゴリ情報は可変ですが

42
00:02:55,310 --> 00:02:58,355
潜在的な値の数は50万にのぼります

43
00:02:58,355 --> 00:03:03,320
そのため50万の情報ノードを作成し

44
00:03:03,320 --> 00:03:09,910
巨大なマトリックスの演算を
行う必要があります