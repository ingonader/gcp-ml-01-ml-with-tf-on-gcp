1
00:00:00,000 --> 00:00:05,110
入力ベクトルを
ワンホットエンコードされた配列として

2
00:00:05,110 --> 00:00:07,870
保存するのはおすすめしません

3
00:00:07,870 --> 00:00:14,505
密表現は保管にも演算にも
極めて非効率的です

4
00:00:14,505 --> 00:00:18,765
ここでは入力テンソルの
すべての値を保管する場所を

5
00:00:18,765 --> 00:00:22,290
みな密テンソルと呼んでいます

6
00:00:22,290 --> 00:00:25,860
これはテンソルに保管される
実際のデータとは無関係で

7
00:00:25,860 --> 00:00:28,490
単に保管方法を表しています

8
00:00:28,490 --> 00:00:31,825
たとえばこのマトリックスですが

9
00:00:31,825 --> 00:00:36,210
データは密でしょうか疎でしょうか

10
00:00:36,210 --> 00:00:38,945
もちろん非常に疎ですね

11
00:00:38,945 --> 00:00:45,695
このマトリックスの例はみな
ユーザーが見た映画を表しています

12
00:00:45,695 --> 00:00:48,500
自分の経験で考えても

13
00:00:48,500 --> 00:00:52,250
評価を付けた映画は多くありませんよね

14
00:00:52,250 --> 00:00:56,430
ですから情報を密のフォームには
入力しません

15
00:00:56,430 --> 00:01:01,260
テンソルのすべての値を
保管する必要はないからです

16
00:01:01,260 --> 00:01:04,239
では密フォームを使用せず

17
00:01:04,239 --> 00:01:07,280
テンソルのすべての値を
保管しないとして

18
00:01:07,280 --> 00:01:10,440
代わりにどうするかというと

19
00:01:10,440 --> 00:01:13,350
データは圧縮したうえで

20
00:01:13,350 --> 00:01:17,110
メモリに疎に保管することにします

21
00:01:17,110 --> 00:01:22,340
こうすれば疎テンソルを
密表現に変換することなく

22
00:01:22,340 --> 00:01:26,065
行列乗算のような演算を

23
00:01:26,065 --> 00:01:30,055
疎テンソルで直接
行うことができます

24
00:01:30,055 --> 00:01:37,535
このために各フィーチャーから整数への
ディクショナリマッピングを作成します

25
00:01:37,535 --> 00:01:41,290
たとえば『シュレック』は整数0とし

26
00:01:41,290 --> 00:01:47,425
『ハリー・ポッター』は300や230など
任意の数値にします

27
00:01:47,425 --> 00:01:50,930
この時点では埋め込みはありません

28
00:01:50,930 --> 00:01:57,005
この時点では単にそれぞれの映画に
任意の整数が関連付けられています

29
00:01:57,005 --> 00:02:03,510
そして特定のユーザーが見た
映画を表すマトリックス行ができたら

30
00:02:03,510 --> 00:02:08,675
単にそのユーザーが見た映画の
映画IDを保存します

31
00:02:08,675 --> 00:02:12,790
この例の行には
3つの映画が示されていますので

32
00:02:12,790 --> 00:02:16,235
疎テンソルには
3つのエントリがあります

33
00:02:16,235 --> 00:02:19,525
このリストに含まれない整数については

34
00:02:19,525 --> 00:02:23,670
その映画は見られていないものと
考えられます

35
00:02:23,670 --> 00:02:26,480
ですから対応する密表現では

36
00:02:26,480 --> 00:02:31,260
この3つのエントリは1で
残りは0となっています

37
00:02:31,260 --> 00:02:33,930
ですので手順は2つです

38
00:02:33,930 --> 00:02:37,325
ディクショナリを計算する
前処理手順と

39
00:02:37,325 --> 00:02:45,485
ディクショナリを使用して効率的な
疎表現を作成する2番目の手順です

40
00:02:45,485 --> 00:02:52,610
これがカテゴリ列のボキャブラリ構築に
似ているなと思われた方は

41
00:02:52,610 --> 00:02:55,010
まさに正解です

42
00:02:55,010 --> 00:03:00,470
カテゴリ列はTensorFlowで
疎テンソルとして表されます

43
00:03:00,470 --> 00:03:05,560
カテゴリ列は
疎なものの例です

44
00:03:05,560 --> 00:03:10,140
TensorFlowは疎テンソルを
密に変換することなく

45
00:03:10,140 --> 00:03:14,310
疎テンソルの演算操作を
実行できます

46
00:03:14,310 --> 00:03:18,490
このためメモリが節約され
演算も最適化されます

47
00:03:18,490 --> 00:03:23,580
カテゴリ列からフィーチャークロスを
作成する方法も説明しましたが

48
00:03:23,580 --> 00:03:30,365
あれは完全に疎テンソルに関して
行われる演算の例です

49
00:03:30,365 --> 00:03:37,480
そのため緯度と経度などという
離散化した列を掛け合わせても

50
00:03:37,480 --> 00:03:42,885
タクシーの乗車ポイントと降車ポイントの
フィーチャークロスを行っても

51
00:03:42,885 --> 00:03:47,205
メモリにも演算速度にも
問題は出ないのです

52
00:03:47,205 --> 00:03:51,690
またフィーチャークロスから埋め込み列を
作成する方法も紹介しましたが

53
00:03:51,690 --> 00:03:56,240
もちろん同じコードを
単一のカテゴリ列にも使用できます

54
00:03:56,240 --> 00:03:58,100
それがこれです

55
00:03:58,100 --> 00:04:02,880
TensorFlowでカテゴリデータから
埋め込み列を作成するコードが

56
00:04:02,880 --> 00:04:06,720
メモリや速度の問題を引き起こさずに
機能できるのは

57
00:04:06,720 --> 00:04:10,180
疎テンソルを扱うことができるからです

58
00:04:10,180 --> 00:04:13,770
これがマジカルな実装の
鍵の1つです

59
00:04:13,770 --> 00:04:20,195
お話したとおり埋め込みに
別個のトレーニングプロセスは不要です

60
00:04:20,195 --> 00:04:22,290
手順は2つだけです

61
00:04:22,290 --> 00:04:25,100
まず元の入力情報を表現し

62
00:04:25,100 --> 00:04:28,055
次にそれを埋め込み層に送ります

63
00:04:28,055 --> 00:04:34,270
最初の手順では入力された情報を
疎テンソルとして表します

64
00:04:34,270 --> 00:04:38,615
2番目の手順では埋め込み列を
呼び出すわけですが

65
00:04:38,615 --> 00:04:42,900
このコードは実際
どのように機能するのでしょうか