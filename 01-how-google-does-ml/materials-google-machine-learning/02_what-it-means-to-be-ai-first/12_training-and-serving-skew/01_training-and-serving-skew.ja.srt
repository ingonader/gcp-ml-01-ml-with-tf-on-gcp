1
00:00:00,000 --> 00:00:03,270
では機械学習を
どのように始めればよいでしょう

2
00:00:03,270 --> 00:00:07,814
私たちの経験上 
最も成功する確率が高いのは

3
00:00:07,814 --> 00:00:10,875
現在 手作業でデータ分析を行っている

4
00:00:10,875 --> 00:00:16,650
ユースケースを選ぶことです

5
00:00:16,650 --> 00:00:18,390
Global Fishing Watchの例を見てみましょう

6
00:00:18,390 --> 00:00:22,740
これは密漁を摘発するNPOです

7
00:00:22,740 --> 00:00:24,300
以前は手作業で漁船の航路を
分析していましたが

8
00:00:24,300 --> 00:00:27,750
機械学習でその処理を行うようにして

9
00:00:27,750 --> 00:00:33,585
毎日2,200万のデータポイントを
分析できるようになりました

10
00:00:33,585 --> 00:00:36,224
手作業のデータ分析を経てから機械学習を

11
00:00:36,224 --> 00:00:40,400
行ったほうがよい理由はいくつかあります

12
00:00:40,400 --> 00:00:43,910
第一に手作業でデータ分析をしているなら

13
00:00:43,910 --> 00:00:47,600
すでにデータがあるからです

14
00:00:47,600 --> 00:00:50,840
データ収集は機械学習プロジェクトで
最も時間がかかる難しい部分とされ

15
00:00:50,840 --> 00:00:54,605
多くがここで失敗します

16
00:00:54,605 --> 00:00:57,110
ですから データがすでにあるのなら

17
00:00:57,110 --> 00:00:59,480
成功する確率がすでに上がっているのです

18
00:00:59,480 --> 00:01:04,190
それが手作業のデータ分析を
経る理由の1つです

19
00:01:04,190 --> 00:01:08,150
２つ目の理由は 現時点で
データがないとしても

20
00:01:08,150 --> 00:01:13,205
MLプロジェクトでは
まずデータの収集と評価を行い

21
00:01:13,205 --> 00:01:16,755
評価はデータのラベルを付ける
という意味なので

22
00:01:16,755 --> 00:01:20,375
手作業での分析が必要なのです

23
00:01:20,375 --> 00:01:23,710
データを分析したところで

24
00:01:23,710 --> 00:01:27,595
意思決定に必要な入力を得られないのなら

25
00:01:27,595 --> 00:01:30,145
機械学習をしても意味がないからです

26
00:01:30,145 --> 00:01:35,790
手作業の分析では失敗して
新しいアイデアを試すこともできます

27
00:01:35,790 --> 00:01:38,500
ですから この分析ステップを
省略しないでください

28
00:01:38,500 --> 00:01:44,485
データから情報を入手できるかどうかは
多くの場合 分析ステップでわかります

29
00:01:44,485 --> 00:01:49,968
手作業のデータ分析を省略しない
3つ目の理由は

30
00:01:49,968 --> 00:01:52,377
良い機会学習モデルの構築に

31
00:01:52,377 --> 00:01:54,040
データを熟知することが不可欠だからです

32
00:01:54,040 --> 00:01:56,350
それが第1段階であるため

33
00:01:56,350 --> 00:02:00,550
手作業のデータ分析が必要です

34
00:02:00,550 --> 00:02:03,015
いきなりMLから始めないでください

35
00:02:03,015 --> 00:02:05,725
この点については
次のモジュールでお話しします

36
00:02:05,725 --> 00:02:12,195
４つ目の理由は
MLが自動化とスケーリングへの道だからです

37
00:02:12,195 --> 00:02:16,685
スケーリングのために
手作業の分析を自動化するのです

38
00:02:16,685 --> 00:02:19,105
Global Fishing Watchのように

39
00:02:19,105 --> 00:02:23,440
手作業で行っていた漁船航路の分析を自動化し

40
00:02:23,440 --> 00:02:28,180
より多くの航路を
分析できるようスケーリングします

41
00:02:28,180 --> 00:02:35,925
分析ができないのであれば MLは不可能です

42
00:02:35,925 --> 00:02:38,720
エンジニアにとって機械学習という言葉は

43
00:02:38,720 --> 00:02:41,305
訓練を連想させるものです

44
00:02:41,305 --> 00:02:46,230
しかし機械学習の真髄と価値は
予測にあります

45
00:02:46,230 --> 00:02:53,295
そこで鍵となるのが
モデルによるストリーミングデータの処理です

46
00:02:53,295 --> 00:02:56,965
ストリーミングデータの洗練化が必要です

47
00:02:56,965 --> 00:02:59,340
一括処理を毎週行うだけで

48
00:02:59,340 --> 00:03:02,960
何とかなると思っていますか？

49
00:03:02,960 --> 00:03:08,545
ビジネスの速度が増すだけです

50
00:03:08,545 --> 00:03:11,160
機械学習製品が失敗する主な理由の1つは

51
00:03:11,160 --> 00:03:15,015
訓練と実働との間に
偏りがあることです

52
00:03:15,015 --> 00:03:17,910
特定のシステムを使い訓練のために

53
00:03:17,910 --> 00:03:20,895
過去のデータを処理しているとします

54
00:03:20,895 --> 00:03:25,395
データサイエンスチームによる
一括処理システムかもしれません

55
00:03:25,395 --> 00:03:28,380
一方 予測に機械学習モデルを必要とする

56
00:03:28,380 --> 00:03:31,840
別のシステムがあるとします

57
00:03:31,840 --> 00:03:35,760
予測のためのシステムは
エンジニアリングチームが

58
00:03:35,760 --> 00:03:40,575
作成して保守しているものでしょう

59
00:03:40,575 --> 00:03:45,360
ウェブフレームワークを使い
Javaで作成されたかもしれません

60
00:03:45,360 --> 00:03:46,965
問題は

61
00:03:46,965 --> 00:03:55,160
モデルが実働時と訓練時に
まったく同じデータを認識しない限り

62
00:03:55,160 --> 00:03:58,930
モデルの予測は
正確でなくなるということです

63
00:03:58,930 --> 00:04:04,250
これが訓練と実働との偏りの問題です

64
00:04:04,250 --> 00:04:08,870
つまり ストリーミング処理の結果と

65
00:04:08,870 --> 00:04:14,230
一括処理の結果が同じである必要が
あるということです

66
00:04:14,230 --> 00:04:21,000
この訓練と実働との間の隔たりの
発生確率を下げるには

67
00:04:21,017 --> 00:04:24,950
訓練時に過去データを処理するために
使用したコードと

68
00:04:24,950 --> 00:04:30,125
同じコードを予測でも使用することです

69
00:04:30,125 --> 00:04:31,840
そのためには

70
00:04:31,840 --> 00:04:36,975
データのパイプラインがバッチも
ストリームも処理しなければなりません

71
00:04:36,975 --> 00:04:39,330
これがデータフローの背後にある重要な点です

72
00:04:39,330 --> 00:04:42,978
データパイプラインをPythonやJava

73
00:04:42,978 --> 00:04:46,125
またCloud Dataブランドで
視覚的に設計する方法です

74
00:04:46,125 --> 00:04:48,750
オープンソースはApache Beamです

75
00:04:48,750 --> 00:04:51,195
「Beam」の「B」はバッチを

76
00:04:51,195 --> 00:04:53,935
「eam」はストリームを表します

77
00:04:53,935 --> 00:04:57,465
バッチとストリームを
処理する1つのシステムです

78
00:04:57,465 --> 00:05:01,731
訓練と予測の両方で
同じシステムを使うため

79
00:05:01,731 --> 00:05:07,850
機械学習で役立ちます

80
00:05:07,850 --> 00:05:11,090
気になるパフォーマンス指標ですが

81
00:05:11,090 --> 00:05:14,755
これは訓練と予測で異なります

82
00:05:14,755 --> 00:05:22,180
訓練中に注目する主なパフォーマンスは
膨大なデータへのスケーリングです

83
00:05:22,180 --> 00:05:24,745
分配の訓練のようなものです

84
00:05:24,745 --> 00:05:33,115
予測の際に注目する主なパフォーマンスは
応答速度つまり 高いQPSです

85
00:05:33,115 --> 00:05:36,650
これがTensorFlowの背後にある
重要な知見です

86
00:05:36,650 --> 00:05:40,890
機械学習の訓練用フレームワークは
多数あります

87
00:05:40,890 --> 00:05:46,000
しかし操作化にも対応できるものは
それほど多くありません