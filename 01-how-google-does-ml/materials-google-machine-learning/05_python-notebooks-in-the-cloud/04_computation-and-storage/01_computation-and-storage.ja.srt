1
00:00:00,000 --> 00:00:03,900
ではComputer Engineと
Cloud Storageについてです

2
00:00:03,900 --> 00:00:09,020
Datalabインスタンスの実行場所である
Computerインスタンスとクラウドの

3
00:00:09,020 --> 00:00:11,225
動作を知っておくと役立ちます

4
00:00:11,225 --> 00:00:13,485
クラウドにある永続的なデータには

5
00:00:13,485 --> 00:00:15,485
Cloud Storageを使用しますから

6
00:00:15,485 --> 00:00:17,660
それも理解する必要があります

7
00:00:17,660 --> 00:00:21,275
Compute Engineは
いわば世界中に分散したCPUです

8
00:00:21,275 --> 00:00:24,915
Cloud Storageは
いわば世界中に分散したディスクです

9
00:00:24,915 --> 00:00:27,815
Datalabは単一ノードのプログラムなので

10
00:00:27,815 --> 00:00:31,716
1つのCompute Engineインスタンスで
実行されます

11
00:00:31,730 --> 00:00:34,085
しかし Dataflowジョブまたは

12
00:00:34,085 --> 00:00:36,795
Cloud ML Engineジョブを始める時

13
00:00:36,795 --> 00:00:41,070
多くのCompute Engineインスタンスに
処理を委ねます

14
00:00:41,070 --> 00:00:44,705
Compute Engineを使えば ワークロードの実行に

15
00:00:44,705 --> 00:00:48,285
クラウド上の仮想マシンを
借りることができます

16
00:00:48,285 --> 00:00:51,175
どんな事をカスタマイズできますか

17
00:00:51,175 --> 00:00:53,495
コース番号 メモリの量

18
00:00:53,495 --> 00:00:55,305
ディスクのサイズ

19
00:00:55,305 --> 00:00:57,535
OSなどです

20
00:00:57,535 --> 00:01:02,255
しかし ロードバランシングや
ネットワーキング等は組み込みです

21
00:01:03,085 --> 00:01:05,475
初期設定にこだわる必要はありません

22
00:01:05,475 --> 00:01:07,475
いつでも変更できます

23
00:01:07,475 --> 00:01:13,040
マシンをどの程度使うかに応じて
自動的に料金が割引になります

24
00:01:13,040 --> 00:01:16,475
Computer Engineインスタンスに
付随するディスクは

25
00:01:16,475 --> 00:01:18,665
高速ですが一時的です

26
00:01:18,665 --> 00:01:22,225
VMがなくなればディスクもなくなります

27
00:01:22,225 --> 00:01:25,485
Googleは永続的なディスクも提供していますが

28
00:01:25,485 --> 00:01:27,440
今はこの点を忘れましょう

29
00:01:27,440 --> 00:01:29,845
Cloud Storageには耐久性があります

30
00:01:29,845 --> 00:01:35,240
つまりCloud Storageにあるblobが複製され
複数の場所に保存されます

31
00:01:35,240 --> 00:01:39,555
さらにCloud Storageは
どのマシンからでもアクセス可能です

32
00:01:39,555 --> 00:01:45,140
Google Centerの分割帯域幅により
ネットワークは高速です

33
00:01:45,140 --> 00:01:48,265
こうして10万台のマシンがお互いに

34
00:01:48,265 --> 00:01:51,755
秒速10ギガバイトで対話できるのです

35
00:01:51,755 --> 00:01:54,925
Cloud Storageから直接読み取ることができます

36
00:01:54,925 --> 00:01:58,605
実際TensorFlowプログラムを
書く時にはそうします

37
00:01:59,405 --> 00:02:01,127
Cloud Storageの目的は

38
00:02:01,127 --> 00:02:04,857
耐久性のあるグローバル
ファイルシステムを提供することですが

39
00:02:04,857 --> 00:02:06,850
その構造はどうなっていますか

40
00:02:06,850 --> 00:02:09,879
典型的なCloud Storage URLは

41
00:02:09,879 --> 00:02:17,549
gs:acme- sales/data/sales003.csv
のようになります

42
00:02:17,549 --> 00:02:21,520
acme-salesはバケットと呼ばれ

43
00:02:21,540 --> 00:02:25,680
バケットの名前は全世界で一意です

44
00:02:25,680 --> 00:02:29,045
ドメイン名やインターネットURL
のようなものです

45
00:02:29,045 --> 00:02:33,860
全世界で一意のバケットを得る方法は
逆ドメイン名を使うことです

46
00:02:33,860 --> 00:02:37,400
この場合 単にプロジェクトIDを使用するか
または

47
00:02:37,400 --> 00:02:40,100
そのドメイン名の所有を証明するよう

48
00:02:40,100 --> 00:02:43,435
Google Cloud Platformから
要求されます

49
00:02:43,435 --> 00:02:47,720
プロジェクトIDも全世界で一意ですから
よほど運が悪くない限り

50
00:02:47,720 --> 00:02:51,360
それがバケット名にすでに使われている
ことはないでしょう

51
00:02:51,360 --> 00:02:57,055
gs URLの他の部分は
フォルダのような構造です

52
00:02:57,885 --> 00:03:03,795
Cloud Storage上のオブジェクトを指す
完全なgs URLを含みます

53
00:03:03,795 --> 00:03:05,955
これをどのように使いますか

54
00:03:05,955 --> 00:03:08,030
gsutilを使用できます

55
00:03:08,030 --> 00:03:12,030
これはGoogle Cloud SDKに付属する
コマンドラインツールです

56
00:03:12,030 --> 00:03:16,950
Compute Engineインスタンスを
スピンアップした場合はgsutilを使用できます

57
00:03:16,950 --> 00:03:20,995
またはラップトップで
Google Cloud SDKをダウンロードして

58
00:03:20,995 --> 00:03:23,160
gsutilを入手できます

59
00:03:23,160 --> 00:03:27,840
gsutilは よく知られたUnixコマンドライン
構文を使用します

60
00:03:27,840 --> 00:03:32,005
たとえばMBやRBはバケットの作成/削除です

61
00:03:32,005 --> 00:03:34,395
コピーするにはCPを使用します

62
00:03:34,395 --> 00:03:36,190
コマンドラインの代わりに

63
00:03:36,190 --> 00:03:38,360
GCP Consoleも使用できます

64
00:03:38,360 --> 00:03:40,540
あるいはprogramming APIや

65
00:03:40,540 --> 00:03:42,880
REST APIも使用できます

66
00:03:42,880 --> 00:03:45,911
ここで多数のファイルsales*.csvを

67
00:03:45,911 --> 00:03:50,601
Cloud Storageの特定の場所に
コピーする方法を見ましょう

68
00:03:50,601 --> 00:03:54,810
先程のとおりCloud Storageバケットには
耐久性があります

69
00:03:54,810 --> 00:03:57,095
つまり重複して保存されます

70
00:03:57,095 --> 00:03:59,635
ここにオブジェクトを格納するだけで

71
00:03:59,635 --> 00:04:03,015
エッジキャッシングと
フェイルオーバーも得られます

72
00:04:03,015 --> 00:04:07,845
しかしCloud Storageがグローバルな
ファイルシステムだからと言って

73
00:04:07,845 --> 00:04:11,565
待ち時間を考慮しなくてよい
わけではありません

74
00:04:11,565 --> 00:04:15,730
データをcomputeノードの近くに
保存するのが良いでしょう

75
00:04:15,730 --> 00:04:19,358
しかしサービスが中断したらどうなりますか

76
00:04:19,358 --> 00:04:23,529
アプリやデータを複数のゾーンに
分散させる必要があります

77
00:04:23,529 --> 00:04:27,685
そうすれば1つのゾーンで
障害が発生しても保護されます

78
00:04:27,685 --> 00:04:30,900
たとえば1つのゾーンで停電があった場合です

79
00:04:30,900 --> 00:04:37,155
それで 必要に応じて冗長度を高めるために
さまざまな地域のゾーンを活用できます

80
00:04:37,155 --> 00:04:42,330
ゾーンとは1つの地域内の
他から離れた場所です

81
00:04:42,330 --> 00:04:46,215
「地域名+ハイフン+ゾーン文字」
という名前です

82
00:04:46,215 --> 00:04:49,400
最後に世界中で利用可能にするには つまり

83
00:04:49,400 --> 00:04:53,650
世界中にお客様が存在する
グローバルなアプリを作る場合には

84
00:04:53,650 --> 00:04:58,330
複数の地域にアプリやデータを
分散させるべきでしょう