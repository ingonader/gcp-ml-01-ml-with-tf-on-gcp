1
00:00:00,000 --> 00:00:04,440
sess.runs zを呼び出すか
z.evalを呼び出して

2
00:00:04,440 --> 00:00:09,045
デフォルトセッションの
コンテキストでzを評価します

3
00:00:09,045 --> 00:00:11,320
z.evalは単なるショートカットです

4
00:00:11,320 --> 00:00:13,615
何度もコーディングするでしょう

5
00:00:13,615 --> 00:00:17,215
デフォルトセッションで
実行を呼び出すのと同じです

6
00:00:17,215 --> 00:00:21,939
sessionか.runを呼び出して
1つのテンソルか

7
00:00:21,939 --> 00:00:26,110
評価するテンソルのリストを渡すことができます

8
00:00:26,110 --> 00:00:28,080
TensorFlowは グラフで

9
00:00:28,080 --> 00:00:31,795
評価の必要がある箇所を評価します

10
00:00:31,795 --> 00:00:34,800
入力テンソルに対応する
NumPy配列は

11
00:00:34,800 --> 00:00:36,880
出力の中にあります

12
00:00:36,880 --> 00:00:39,975
zとz3を渡したので

13
00:00:39,975 --> 00:00:45,200
a1とa3という
NumPy配列で返されます

14
00:00:45,200 --> 00:00:52,620
コードを見ると tf.add( x,y)と記述する
必要がないこともわかります

15
00:00:52,620 --> 00:00:55,120
単に「x+y」と記述できます

16
00:00:55,120 --> 00:00:59,325
算術演算が共通で
オーバーロードされるからです

17
00:00:59,325 --> 00:01:03,195
tf.eagerについては
すでに簡単に説明しました

18
00:01:03,195 --> 00:01:06,675
通常 TensorFlowプログラムは
遅延評価を使用します

19
00:01:06,675 --> 00:01:10,830
本番環境のコードを書く際は
これをおすすめします

20
00:01:10,830 --> 00:01:15,570
開発やデバッグでは
コードを後で実行するよりも

21
00:01:15,570 --> 00:01:20,680
即座に実行したほうが
都合が良いことがあります

22
00:01:20,680 --> 00:01:24,380
そこでtf.eagerの使用方法を説明します

23
00:01:24,380 --> 00:01:29,090
tf eagerをインポートして
先行（eager）実行を有効にします

24
00:01:29,090 --> 00:01:31,440
これは一度だけ

25
00:01:31,440 --> 00:01:34,165
通常はmiの開始時に行います

26
00:01:34,165 --> 00:01:38,295
2つのテンソルxとyを作成し

27
00:01:38,295 --> 00:01:40,775
x-yを出力します

28
00:01:40,775 --> 00:01:43,505
eagerモードでなければ

29
00:01:43,505 --> 00:01:45,820
出力されるのは

30
00:01:45,820 --> 00:01:49,125
テンソルのデバッグ出力だけです

31
00:01:49,125 --> 00:01:51,950
システムで割り当てられた

32
00:01:51,950 --> 00:01:55,235
ノードの一意の名前、DAG、形状、
デバッガ実行で

33
00:01:55,235 --> 00:01:58,640
表示される値の
データ型が含まれます

34
00:01:58,640 --> 00:02:02,035
今は eagerモードであるため

35
00:02:02,035 --> 00:02:07,040
減算の結果を得るのに
セッションの実行を待つ必要がありません

36
00:02:07,040 --> 00:02:11,030
ですから x-yを実行すると

37
00:02:11,030 --> 00:02:14,350
リスト「2, 3, 4」が表示されます