You can call sess.runs z or you can call z.eval to evaluate z in the context of the default session. z.eval is just a shortcut, and you will often see it and code. It is the same as calling run on the default session. While you can call session.run and passing a single answer, you can also pass in a list of tensors to evaluate. TensorFlow will figure out which parts of the graph it needs to evaluate and carry out the evaluation. For each input tensor, there is a corresponding numPy array in the output. Since we passed in z and z3, you get back to numPy arrays that I'm calling a1 and a3. Notice that this code also shows that you don't need to write out tf.Add( x,y). You can simply say x plus y, because the common arithmetic operations, they're overloaded. I briefly mentioned tf.eager earlier. Commonly, TensorFlow programs use the lazy evaluation, and this is what I recommend when you're writing production code. However, when you're developing, when you're debugging, it can sometimes be convenient to have the code executed immediately instead of lazily. So here, I'm showing how to use tf.eager. You import tf eager and enable eager execution. But make sure to do this only once. Typically you do it at the start of your mi. So here, I'm creating two tensors x and y, and printing out x minus y. If we are not an eager mode, what would get printed out? Just the debug output of the tensor. This would have included a system assigned a unique name for the node and the Dagg and the shape, and the datatype of the value that will show up when the daggers run. But because we are in eager mode, we don't have to wait for session that run to get the actual result of the subtraction. That's why, when I do x minus y, you see the list 2, 3, 4.