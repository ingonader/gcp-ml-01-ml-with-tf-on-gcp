TensorFlowについて
説明しました API階層も確認しました セッションでの
有向非巡回グラフ（DAG）の 実行方法についても説明しました DAGは テンソルと
テンソルの演算で構成されます ここでテンソルについて
さらに詳しく見てみましょう テンソルはn次元のデータ配列です テンソルを作成する際
通常は形状を指定しますが 完全には指定しないこともあります 形状の最初の要素は
変数にできますが そうした特殊なケースは
今は無視します ここでは tf.constant(3)を
作成しています 0ランクのテンソルです 単一の数値
つまりスカラーです テンソルのデバッグ出力を見ると
形状は「( )」になります これが0ランクです 一方で「3, 5, 7」というリストを
tf.constantに渡すと 1次元テンソル
つまりベクトルになります 最初の行に「3, 5, 7」 2行目に「4, 6, 8」を指定して 2次元の配列を渡します テンソルの形状は
「2, 3」になりますが これは2行3列を意味し
ランクは2です 行列は 1次元テンソルの
積み重ねと見なすことができます 最初のテンソルはベクトル「3, 5, 7」で スタックの2番目の1次元テンソルは
ベクトル「4, 6, 8」です 同様に2次元行列を
積み重ねることで 3次元の行列を作成できます 「3, 5, 7」で始まる行列を
「1, 2, 3」に積み重ねます 2行3列の行列を 2つ積み重ねたので テンソルの形状は
「2, 2, 3」になります これらのかっこを数えなくても コードで積み重ねることができます ここでは「x1」が定数で
単純な「2, 3, 4」で構成されます これは 長さ3のベクトルになります 「x2」は「x1」に「x1」を
積み重ねて作成され 2行3列の行列になります 「x3」は4つの「x2」を
互いに積み重ねて作成されます 各「x2」は2行3列の
行列なので 「x3」は「4, 2, 3」の
3次元テンソルになります 「x4」は「x3」に「x3」を
積み重ねて作成されます 「4, 2, 3」のテンソル
2つで構成される つまり「2, 4, 2, 3」の
4次元テンソルになります 積み重ねることで より高い次元のテンソルを
作成できます また テンソルをスライスして 低い次元のテンソルを
抜き出すこともできます この場合「x」の形状は何でしょうか 「2, 3」
2行3列です 「y」のコードに注目してください 「x」をスライスしています コロンは すべての行を取得することを示し 「1」は1列だけ取得することを意味します Pythonではゼロから数えるため
実際には2番目の列です 「y」を評価する際に
すべての行で2列目の値を取得します そのため「5, 6」が出力されます ここで質問です
x[1, :] の値はどうなりますか これを実行するとどうなりますか x[1, 0:2]についてはどうでしょうか
実行するとどうなりますか 答えは x[1, : ]を実行すると
2行目を取得します ゼロから数えるので 「1」は2行目です すべての列を取得し [4, 6, 8]が得られます では 0:2はどの列を抜き出しますか これは Pythonのx range関数に
似ています 0から開始して2つ進みますが
2は含みません 「0」と「1」という意味です これは 両方の行を取得することを意味するため 実際には同じ「4, 6, 8」が得られます データがテンソルに挿入されたら すべてのデータを使って
形状を調整できます 「x」は2次元テンソルですが
形状は何でしょう そう「2, 3」です 形状を「3, 2」に変更すると
どうなるでしょう 「x」に6個の値が必要ですが それらを3行2列に配置することになります 基本的にPythonは行ごとに
入力テンソルを読み取り 出力テンソルに数値を配置します 最初の2つの値を
最初の行に配置します 「3」と「5」となります 次の2つの値「7」と「4」が
2行目に入り 最後の「6」と「8」が
3行目に入ります 形状の調整によって
こうなります 形状は調整も
スライスも可能です 「3, 2」に変更して
スライスすると 2行目のすべての列のみが
取得されます 結果、「7, 4」が得られます