1
00:00:00,000 --> 00:00:02,835
このコードをご覧ください

2
00:00:02,835 --> 00:00:08,039
一見すると NumPyにそっくりです

3
00:00:08,039 --> 00:00:11,305
テンソルaとbを加算するために

4
00:00:11,305 --> 00:00:14,710
tf.add(a, b)と記述すると

5
00:00:14,710 --> 00:00:21,240
テンソルcが返ってきます
典型的なPythonコードとは異なり

6
00:00:21,240 --> 00:00:25,075
tf.addを実行しても
このコードは実行されず

7
00:00:25,075 --> 00:00:28,660
DAGが構築されるだけです

8
00:00:28,660 --> 00:00:34,410
DAG（有向非巡回グラフ）では
a、b、cがテンソルで

9
00:00:34,410 --> 00:00:37,125
addが演算です

10
00:00:37,125 --> 00:00:39,545
このコード

11
00:00:39,545 --> 00:00:41,965
つまりDAGは

12
00:00:41,965 --> 00:00:47,690
セッションの中で
実行する必要があります

13
00:00:47,690 --> 00:00:51,430
たとえばcの値が必要な場合は

14
00:00:51,430 --> 00:00:56,080
「c の値を評価しろ」と
セッションに指示します

15
00:00:56,080 --> 00:00:58,720
こうして DAGが実行され

16
00:00:58,720 --> 00:01:04,590
cの値を収めた従来型の
Python数値配列が返されます

17
00:01:04,590 --> 00:01:09,395
TensorFlowのプログラミングには
DAGのプログラミングも含まれます

18
00:01:09,395 --> 00:01:11,285
2つのステップがあり

19
00:01:11,285 --> 00:01:13,835
最初のステップでグラフを作って

20
00:01:13,835 --> 00:01:16,675
2番目のステップで実行します

21
00:01:16,675 --> 00:01:20,465
これは遅延評価モデルのため

22
00:01:20,465 --> 00:01:24,240
グラフ定義とトレーニングループは別々です

23
00:01:24,240 --> 00:01:28,850
これはPythonからC++への

24
00:01:28,850 --> 00:01:33,045
コンテキストスイッチを最小限に抑え
計算を効率化します

25
00:01:33,045 --> 00:01:37,165
概念的には
プログラムを書いてコンパイルした後

26
00:01:37,165 --> 00:01:39,945
データを使って
実行するようなものです

27
00:01:39,945 --> 00:01:42,470
でも 完全に同じだと考えないでください

28
00:01:42,470 --> 00:01:45,365
明示的なコンパイルフェーズはありません

29
00:01:45,365 --> 00:01:48,540
tf.addを呼び出した後のcは

30
00:01:48,540 --> 00:01:51,400
実際の値ではありません

31
00:01:51,400 --> 00:01:55,360
TensorFlowセッションの
コンテキストでcを評価し

32
00:01:55,360 --> 00:02:00,450
NumPy値配列numpy_c を
得る必要があります

33
00:02:00,450 --> 00:02:06,375
繰り返しになりますが
TensorFlowは遅延評価を行います

34
00:02:06,375 --> 00:02:13,890
DAGを書いた後にセッションの
コンテキストで実行して結果を得ます

35
00:02:13,890 --> 00:02:17,260
さて TensorFlowを実行できる
別のモードがあります

36
00:02:17,260 --> 00:02:19,670
tf.eagerといいます

37
00:02:19,670 --> 00:02:23,355
評価は即時に行われて
遅延がありません

38
00:02:23,355 --> 00:02:27,890
先行モードは通常
本番環境プログラムではなく

39
00:02:27,890 --> 00:02:30,230
開発で使用されます

40
00:02:30,230 --> 00:02:33,795
後でtf.eagerに少し触れますが

41
00:02:33,805 --> 00:02:37,865
遅延評価プログラムに焦点を置きます

42
00:02:37,865 --> 00:02:41,430
本番環境用に書いて実行する
大半のコードは

43
00:02:41,430 --> 00:02:44,850
遅延評価モードになります

44
00:02:44,850 --> 00:02:50,355
Python数値計算ソフトウェアの大部分は
NumPyで書かれますが

45
00:02:50,355 --> 00:02:53,505
aとbはNumPy配列です

46
00:02:53,505 --> 00:02:57,675
NumPyはcで実装されると
スピードを発揮します

47
00:02:57,675 --> 00:03:02,770
np.addを呼び出すと
加算はcで実行されますが

48
00:03:02,770 --> 00:03:08,730
実行されるのは
CPUがnp.add (a, b)を実行するときです

49
00:03:08,730 --> 00:03:12,360
そしてNumPy配列cに和が入ります

50
00:03:12,360 --> 00:03:14,265
print cを実行すると

51
00:03:14,265 --> 00:03:16,825
8、2、10が出力されます

52
00:03:16,825 --> 00:03:18,645
8は5と3の和です

53
00:03:18,645 --> 00:03:21,590
2は3と-1の和
などになります

54
00:03:21,590 --> 00:03:27,455
要点は np.addが直ちに評価されることです

55
00:03:27,455 --> 00:03:36,065
NumPyとは異なり TensorFlowでは
cは実際の値ではなくテンソルです

56
00:03:36,065 --> 00:03:40,840
TensorFlowセッションのコンテキストで
cを評価して

57
00:03:40,840 --> 00:03:45,315
NumPy値配列を
取得する必要があります

58
00:03:45,315 --> 00:03:52,159
CPU、GPU などのハードウェアが
tf.add (a, b)を評価する際に

59
00:03:52,159 --> 00:03:57,165
テンソルがDAGで生成されます

60
00:03:57,165 --> 00:04:03,985
加算自体は sess.runが
呼び出されて初めて実行されます

61
00:04:03,985 --> 00:04:06,905
print cを呼び出すと

62
00:04:06,905 --> 00:04:12,090
最初のボックスに出力されるのは
テンソルクラスのデバッグ出力です

63
00:04:12,090 --> 00:04:17,220
これには DAGのノードに対して
割り当てられた固有名が含まれます

64
00:04:17,220 --> 00:04:19,760
この場合はadd_7です

65
00:04:19,760 --> 00:04:24,785
DAGの実行時に表示される
値の形状とデータ型も表示されます

66
00:04:24,785 --> 00:04:30,655
セッションの実行時に
そのコンテキストで cが評価された後

67
00:04:30,655 --> 00:04:32,660
結果を出力すると

68
00:04:32,660 --> 00:04:35,790
NumPyと同じく
8、2、10が表示されます

69
00:04:35,790 --> 00:04:37,630
ここには構築ステージと

70
00:04:37,630 --> 00:04:41,630
実行ステージがありますが
なぜでしょう

71
00:04:41,630 --> 00:04:46,580
なぜTensorFlowは
遅延評価を行うのでしょうか

72
00:04:46,580 --> 00:04:48,930
次のレッスンで説明しましょう