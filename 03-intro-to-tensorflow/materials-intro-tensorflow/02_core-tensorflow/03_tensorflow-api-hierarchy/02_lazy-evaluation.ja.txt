このコードをご覧ください 一見すると NumPyにそっくりです テンソルaとbを加算するために tf.add(a, b)と記述すると テンソルcが返ってきます
典型的なPythonコードとは異なり tf.addを実行しても
このコードは実行されず DAGが構築されるだけです DAG（有向非巡回グラフ）では
a、b、cがテンソルで addが演算です このコード つまりDAGは セッションの中で
実行する必要があります たとえばcの値が必要な場合は 「c の値を評価しろ」と
セッションに指示します こうして DAGが実行され cの値を収めた従来型の
Python数値配列が返されます TensorFlowのプログラミングには
DAGのプログラミングも含まれます 2つのステップがあり 最初のステップでグラフを作って 2番目のステップで実行します これは遅延評価モデルのため グラフ定義とトレーニングループは別々です これはPythonからC++への コンテキストスイッチを最小限に抑え
計算を効率化します 概念的には
プログラムを書いてコンパイルした後 データを使って
実行するようなものです でも 完全に同じだと考えないでください 明示的なコンパイルフェーズはありません tf.addを呼び出した後のcは 実際の値ではありません TensorFlowセッションの
コンテキストでcを評価し NumPy値配列numpy_c を
得る必要があります 繰り返しになりますが
TensorFlowは遅延評価を行います DAGを書いた後にセッションの
コンテキストで実行して結果を得ます さて TensorFlowを実行できる
別のモードがあります tf.eagerといいます 評価は即時に行われて
遅延がありません 先行モードは通常
本番環境プログラムではなく 開発で使用されます 後でtf.eagerに少し触れますが 遅延評価プログラムに焦点を置きます 本番環境用に書いて実行する
大半のコードは 遅延評価モードになります Python数値計算ソフトウェアの大部分は
NumPyで書かれますが aとbはNumPy配列です NumPyはcで実装されると
スピードを発揮します np.addを呼び出すと
加算はcで実行されますが 実行されるのは
CPUがnp.add (a, b)を実行するときです そしてNumPy配列cに和が入ります print cを実行すると 8、2、10が出力されます 8は5と3の和です 2は3と-1の和
などになります 要点は np.addが直ちに評価されることです NumPyとは異なり TensorFlowでは
cは実際の値ではなくテンソルです TensorFlowセッションのコンテキストで
cを評価して NumPy値配列を
取得する必要があります CPU、GPU などのハードウェアが
tf.add (a, b)を評価する際に テンソルがDAGで生成されます 加算自体は sess.runが
呼び出されて初めて実行されます print cを呼び出すと 最初のボックスに出力されるのは
テンソルクラスのデバッグ出力です これには DAGのノードに対して
割り当てられた固有名が含まれます この場合はadd_7です DAGの実行時に表示される
値の形状とデータ型も表示されます セッションの実行時に
そのコンテキストで cが評価された後 結果を出力すると NumPyと同じく
8、2、10が表示されます ここには構築ステージと 実行ステージがありますが
なぜでしょう なぜTensorFlowは
遅延評価を行うのでしょうか 次のレッスンで説明しましょう