So in this lab, just as we did in previous labs, you go ahead and you go into the GCP Console, get into Cloud Shell, start Datalab. And once we are in Datalab, I'm going to navigate to the notebook to get started with TensorFlow. So the first cell in this notebook is to import tensorflow and numpy packages because we're going to be playing around with both of them. So, I can go ahead and run that cell and that's essentially telling me that I'm running TensorFlow 1.4 in this instance, and then, I'm going to show how to add two numpy arrays. So I have one numpy array which is A, and another numpy array which is B. And in this case I'm adding numpy np.add (a, b) and printing C. Because this is numpy, all of the score is getting evaluated immediately. So when I go ahead and run it, I get eight, two, 10. So that's my list. The equivalent code in TensorFlow is of two steps. So let's just run just the first step. The first step, again as in numpy we created A, we're going to create A where np.array, we do tf.constant. So I'm creating a constant array A, I'm creating another constant array B, I'm calling tf.add (a, b) but this time when I print C, you will not see the list eight, two, and 10. What do you see? What you see is a debug output of the tensor. So in this case, we say that the C is a result of add operation. It's going to contain three numbers and they're all going to be integers. So that is a step one, building the graph. So let's go and try something out. Let's go ahead and change this to be, for example 5.0. At this point A now becomes not an array of ints, but an array of floats. So let's go ahead and print not just C, but let me go ahead and print A the imprint A is so you know what I'm talking about. And now when I run it, you see that A is of type float and at this point now we cannot add A and B because A is type float but B is of type int, and that's why I get the error. But I can go ahead and change this also to be a float and when I run it, C is going to be of type float. So, that's one thing to remember. So let me go ahead and change it back to be integer so that we can do the next step. So in this case I have A and C, and the next step of my graph is to go ahead and evaluate the value of C. This is how I'm going to get the numbers. Remember, build the graph, run the graph. So in this case I'm going to do sess.run(c) and then print the result. Result is going to be a regular old array. And when I go ahead and print it I get eight, two, and 10. So the thing to remember is that in TensorFlow it's lazy evaluation. Step number one, build the graph. Step number two, run the graph. Now, in this case, everything in my graph was hard coded. Normally though, you will basically have things be a placeholder so you can get information in at runtime. So in my case, I'm basically creating A to be a placeholder that's going to basically contain a list, and B is going to be another placeholder that's contain a list. I'm going to add A and B and now I'm passing in the numbers three, four and five at runtime. When I'm running the session, I'm passing in three, four, and five for A, and minus one, two, three for B. And now when I print result I'm going to get two, six, and eight because three minus one is two. But in this case, remember that these three lines are about building the graph A, B, and C as well building the graph. The rest of them is about running the graph and when I run the graph I'm feeding in values. So we can now put both of these concepts together when it comes to basically doing something useful. So the thing that we're going to do is that we're going to basically say given a triangle, the sides of the triangle, let me go ahead and compute the area of the triangle. There is a formula called Heron's Formula that's basically this formula here. And that's what we're going to implement in TensorFlow. Again, TensorFlow is not just about neural networks, it's about any numeric programming. So sure we can also compute the area of a triangle in TensorFlow. So I have my method, my function to compute the area given the sides. But one thing to remember is that you're not going to use TensorFlow to compute the area of one triangle. You're going to use TensorFlow to create the area of lots and lots and lots of triangles. So we're going to decide it's not going to be one set of three numbers, it's going to be and lot of sets of three numbers, right? So we're going to basically get a number of triangles and now we want to get there A's and the B's and the C's, the three sides. A is going to be slicing that sides which is basically going to be the batch size, the number of triangles that we have, times three because we have three of them. So the first column is going to A, the second column is going to be B, and the third column is going to be C. So in this case I'm getting the first column which is A, the second column which is B, and the third column which is C. So if we are going to be passing in F two by three matrix here, we're passing the two by three matrix of two triangles. Each triangle has three sides. The first set of side is five and 2.3, that's the A, three and 4.1, that's the B, and 7.1 And 4.8, that's your C. So we now have your A, B, and C. We compute half the perimeter, so A plus B plus C divide by two, and then use that formula to compute the area square. Compute the square root of that and we return it. So all of this is part of building the graph and when we want to run the graph, we can basically go ahead and say sess.run but this time I want to compute the variable area or the TensorFlow tensor area, and the way we get the area is to call compute area passing in these values. So if I now run this, I'm going to basically get the area of two triangles. That's why I'm getting two numbers here, there're two triangles. But here are hard coded these numbers. You may not want a hard cord them, you may want to feed them in. So that's what this last thing is showing. It's showing using the same compute area but the sides now are basically fed into the graph. So sides is a placeholder, it's no longer a tf constant. And then when you run and you want to evaluate the area, we're going to pass in a key value pair. The key is the name of the tensor sides, and the value is now your 2D array because you're passing in and array of triangles. So we can now run this and that basically shows essentially the same result. The last part of the notebook is showing you how we can avoid this two step, build the graph, run the graph by using tf eager. So the way we're doing this now is that we are basically calling enable eager execution. By calling these, we basically ensure that now there's not two steps anymore. It's not build the graph, run the graph but the process of building the graph, all the things that we're doing, things are going to get evaluated immediately. So in this case I'm creating the compute area, I'm doing exactly the same thing, and I'm saying area is compute area print area. If I did not have eager execution, so let me go ahead and comment this out so you can see what I'm talking about. If I don't have eager execution and I do print area, I'm just going to get the debug output of the tensor. So that is a debug output of the tensor. I'm not actually getting the values here, I'm just getting that this is going to contain the answer for two triangles. But now I'll go on and enable eager execution and then go ahead and run it. And when we do this, you notice that the output contains the actual values. I'm still calling print area. I haven't called session.run print area. But this time, I'm actually getting the answer back.